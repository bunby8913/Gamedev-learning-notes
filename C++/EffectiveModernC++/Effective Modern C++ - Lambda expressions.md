# Effective Modern C++ - Lambda expressions

- Everything that lambda van do can be done previously in C++

	- Just a convenient way to create function object
	- nontrivial conditions in STL functions
	- on-the-fly specification of callback functions

- An example of lambda expression

	- ```c++
		[](int val) {return 0 < val && val < 10};
		```

- Closure: the runtime object created by a lambda, holds all the captured data (copy / reference)
	- Each lambda has a unique closure class, generated by compiler
	- Lambda expression statement is a member function executed inside the closure class
- Lambda often used as one-off arguments for a function
- Each lambda unique closure class can have multiple instances of the same type

### Avoid default capture modes

- 2 default capture mode in C++11, by value / by reference

	- Both can lead to dangling reference + closure are not self contained

- The danger of default by-reference capture

	- Reference to local variable / parameter within the same scope as the lambda definition
	- Dangle reference is the closure has longer lifetime than the variable it reference to
	- If the lambda expression is stored for later use but 1 of the captured value has already been destroyed, that's a dangling reference
		- `[&]`: Indicate all local variable within the same scope as Lambda expression are being captured (The default by-reference capture mode)
	- No risk if the lambda expression will be used immediately (within the same scope)
		- However, error will still occur if the lambda is being used outside the scope
	- Better software engineering to list every variables + parameter used by the lambda expression
	- Solution: Using default by-value capture mode `[=]`

- The danger of default by-value capture

	- if a pointer is captured by value, copying the pointer address does not prevent the pointer being deleted (even using smart pointers won't)

- Lambda capture only applied to non-static local variables in the same scope of the lambda declarations

	- Data member of the class lambda a part of does not count (Cannot be captured)
		- More specifically, the `this` pointer is being captured instead of the data member when using the default by-value capture
		- Cannot capture the data member directly by name + cannot capture the data member by reference

- Solution to storing dangling pointer in lambda capture: make a local of the data member + capture the copy by value

	- ```c++
		void MyClass::addFilter() const
		{
		    auto filterVar = filter; // filter is a local data member
		    filters.emplace_back([filterVar](int value) {return value % filterVar ==0;});
		}
		// default by-value capture will work too
		```

- C++14 introduced generalized lambda capture

	- ```c++
		filters.emplace_back([divisor = divisor](int value) {return value % divisor == 0;});
		```

- Object with static storage duration (global variable, static member of the class, etc.) cannot be captured but can be used within the lambda expression

	- The value of the static member is not captured by lambda expression, so change of static member will change the behavior of lambda (even if it's not intended)
	- Avoid default by-value capture can avoid this problem

### Use init capture to move objects into closures

- C++14 offers direct support to move object into closures

	- C++11 has ways to simulate the move capture

- Init capture: New flexible capture mechanism (Generalized lambda capture)

	- Cannot perform default capture mode (should avoid it anyway)

	- Provide a name to data member captured by the closure class

	- Provide a way to initialize the data member

		- ```c++
			auto func = [pw = std::move(pw)]{return pw->someFunc();};
			```

	- Left of `=` defines the name of the data member in the closure class, scope within the class

	- Right of `=` initialize the data member, scope is same as the lambda declaration

	- Possible to create + initialize using the created object on the same line

		- ```c++
			auto func = [pw = std::make_unique<MyClass>()]...;
			```

- Since lambda simply creates a new class + generate a new object of the class, in C++11, we can create the class ourself + perform the data member initialization manually

	- To continue to use lambda in C++11 with move capture, do the following

		- Move object to be captured into a function object using `std::bind`
		- Give the lambda the reference of the function object

	- ```c++
		// C++14
		auto func = [data = std::move(data)]{ /*Using data*/;};
		//C++11
		auto func = std::bind([](const std::vector<double>& data){/*Using data*/;}, std::move(data));
		```

	- `std::bind` takes 2 arguments, first the callable object (the lambda expression in this case), the rest of the arguments passes the value to the callable object

		- Copy construct every L-value arguments to the function + move construct every R-value arguments
		- The bind object passes all the arguments to the callable object when called
		- In the sample above, data is an L-value reference converted into R-value using `std::move` when passed to the lambda expression
		- Usually, lambda prevent the copied in data from being modified by making the member function `const`
			- If modification of the data is intended, then `mutable` should be added + `const` should be removed

	- Characteristic of `std::bind`

		- Possible to move-construct an object in C++ using bind object 
		- Move construct an object in bind object + pass the move-constructed object to lambda expression is equivalent of move-capture in C++14
		- Bind object has the same life time as lambda expression, bind constructed object can be treated as they are in the closure

### use `decltype` on `auto&&` parameters to `std::forward` them

- Generic lambda: lambda that uses `auto` to deduce parameter type

	- If the type can be deduced, should consider the possibility of perfect forwarding
		- Both L-value + R-value should able to be passed through
	- 2 things need to be done, make the parameter a universal reference (`auto&&`) + use `std::forward` to forward the parameter to any function needed
		- Simple in concept, the question lies on what type should `std::forward` use
			- Cannot use simply use `T`, since the type if deduced in lambda, no parameter T is available to us

- Solution: use `decltype`, which will return the type of the parameter + the type of reference it is

	- Instantiating `std::forward` with R-value reference yield the same result as non-reference type
	- Both L-value + R-value reference can be passed using `decltype` with expected result

- For a Lambda to use perfect forwarding + auto parameter (in C++14)

	- ```c++
		auto f = [](auto&& param) {return func(normalize(std::forward<decltype(param)>(param)));};
		// To pass multiple arguments using variadic
		auto f = [ (auto&& ... params){return func(normalize(std::forward<decltype(param)>(params)...))}]
		```

### Prefer lambdas to `std::bind`

- In both C++11 + C++14, Lambda is almost always the better choice than `std::bind`
	- Lambda are more readable than `std::bind`
	- `std::bind` does not work well with overloaded function, cannot simply determine which version of the function to pass the parameter too
		- Using lambda can automatically the # of parameters + which overloaded function to use
	- `std::bind` uses function pointer to call the function its bound to, less likely to be converted to `inline`, hence, less optimized than lambda functions
- Lambda functions will reflect if the value is passed by reference + value clearly when capturing the variable
	- `std::bind` will pass by value
- 
